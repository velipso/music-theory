<!doctype html>
<html lang="en">
<head>
<!--
(c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc
MIT License
Project Home: https://github.com/voidqk/music-theory
-->
	<title>Chord Progression Player</title>
	<style>
html, body {
	background: #eef;
	font-family: sans-serif;
}
input, select, option, textarea {
	font-family: monospace;
	font-size: 18px;
}
button {
	font-size: 18px;
}
table button {
	font-family: monospace;
	width: 100%;
}
p {
	line-height: 1.3em;
	text-align: justify;
}
td, th {
	padding: 2px 5px;
	vertical-align: middle;
}
code {
	background: #fff;
	border: 1px solid #bbb;
	padding: 2px;
	font-size: 14px;
}
.doit {
	font-size: 24px;
}
#out {
	font-family: monospace;
	font-size: 80px;
	border: 1px solid #888;
	background-color: #aaa;
	text-align: center;
	margin-top: 0;
	margin-bottom: 0;
}
ol {
	margin-top: 0;
}
	</style>
	<script>
var noteHit = (function(){
	var opts = {
		osc1type: "square"  , osc1vol: 0.3, osc1tune:   0,
		osc2type: "sine"    , osc2vol: 0.2, osc2tune:  12,
		osc3type: "triangle", osc3vol: 0.1, osc3tune: -12,
		attack  : 0.02,
		decay   : 1.0,
		sustain : 0.5,
		susdecay: 5,
		cutoff  : 15
	};
	var AudioContext = window.AudioContext || window.webkitAudioContext;
	var ctx = new AudioContext();
	function SimpleJSSynth(){
		// copied and simplified from: https://github.com/voidqk/simple-js-synth
		var filter = ctx.createBiquadFilter();
		filter.type = 'lowpass';
		filter.frequency.setValueAtTime(22050, ctx.currentTime);
		filter.Q.setValueAtTime(0.5, ctx.currentTime);
		var my = filter;
		var gain = ctx.createGain();
		gain.gain.setValueAtTime(0, ctx.currentTime);
		gain.connect(filter);
		function oscgain(v){
			var g = ctx.createGain();
			g.gain.setValueAtTime(0, ctx.currentTime);
			g.connect(gain);
			return { node: g, base: v };
		}
		var osc1gain = oscgain(opts.osc1vol);
		var osc2gain = oscgain(opts.osc2vol);
		var osc3gain = oscgain(opts.osc3vol);
		function osctype(type, g){
			var osc = ctx.createOscillator();
			osc.type = type;
			osc.connect(g);
			return osc;
		}
		var osc1 = osctype(opts.osc1type, osc1gain.node);
		var osc2 = osctype(opts.osc2type, osc2gain.node);
		var osc3 = osctype(opts.osc3type, osc3gain.node);
		function calctune(t){ return Math.pow(2, t / 12); }
		var tune1 = calctune(opts.osc1tune);
		var tune2 = calctune(opts.osc2tune);
		var tune3 = calctune(opts.osc3tune);
		var cutoff = calctune(opts.cutoff);
		var eps = 0.001;
		var attack   = Math.max(opts.attack  , eps);
		var decay    = Math.max(opts.decay   , eps);
		var sustain  = Math.max(opts.sustain , eps);
		var susdecay = Math.max(opts.susdecay, eps);
		var basefreq = 0;
		var silent = 0;
		var ndown = false;
		osc1.start();
		osc2.start();
		osc3.start();
		my.connect(ctx.destination);
		my.noteOn = function(freq, vol){
			ndown = true;
			basefreq = freq;
			var now = ctx.currentTime;
			osc1.frequency.setValueAtTime(freq * tune1, now);
			osc2.frequency.setValueAtTime(freq * tune2, now);
			osc3.frequency.setValueAtTime(freq * tune3, now);
			filter.frequency.setValueAtTime(Math.min(freq * cutoff, 22050), now);
			osc1gain.node.gain.setValueAtTime(vol * osc1gain.base, now);
			osc2gain.node.gain.setValueAtTime(vol * osc2gain.base, now);
			osc3gain.node.gain.setValueAtTime(vol * osc3gain.base, now);
			var v = gain.gain.value;
			gain.gain.cancelScheduledValues(now);
			gain.gain.setValueAtTime(v, now);
			var hitpeak = now + attack;
			var hitsus = hitpeak + decay * (1 - sustain);
			silent = hitsus + susdecay;
			gain.gain.linearRampToValueAtTime(1, hitpeak);
			gain.gain.linearRampToValueAtTime(sustain, hitsus);
			gain.gain.linearRampToValueAtTime(0.000001, silent);
		};
		my.noteOff = function(){
			ndown = false;
			var now = ctx.currentTime;
			var v = gain.gain.value;
			gain.gain.cancelScheduledValues(now);
			gain.gain.setValueAtTime(v, now);
			silent = now + decay * v;
			gain.gain.linearRampToValueAtTime(0.000001, silent);
		};
		my.isReady = function(){
			return ctx.currentTime >= silent && !ndown;
		};
		return my;
	}
	var pool = [];
	for (var i = 0; i < 20; i++)
		pool.push(SimpleJSSynth());
	var notedown = [];
	for (var i = 0; i < 128; i++)
		notedown.push(false);
	return function(note, vel){
		if (notedown[note]){
			notedown[note].noteOff();
			notedown[note] = false;
		}
		if (vel <= 0)
			return;
		for (var i = 0; i < pool.length; i++){
			if (pool[i].isReady()){
				pool[i].noteOn(440 * Math.pow(2, (note - 69) / 12), vel);
				notedown[note] = pool[i];
				return;
			}
		}
	};
})();
	</script>
</head>
<body>
	<div style="float: left;">
	<p>
		Key: <select id="keyof">
			<option value="0">C</option>
			<option value="1">Db</option>
			<option value="2">D</option>
			<option value="3">Eb</option>
			<option value="4">E</option>
			<option value="5">F</option>
			<option value="6">Gb</option>
			<option value="-5">G</option>
			<option value="-4">Ab</option>
			<option value="-3">A</option>
			<option value="-2">Bb</option>
			<option value="-1">B</option>
		</select>
	</p>
	<p>
		Tempo: <input id="bpm" size="5" type="text" value="70" /> BPM
	</p>
	<p>
		Volume:
		<button onclick="javascript: addVolume(-10);">&larr;</button>
		<span id="vol">?</span>
		<button onclick="javascript: addVolume(10);">&rarr;</button>
	</p>
	<p>
		Progression:
	</p>
	<textarea rows="20" cols="20" id="prog" spellcheck="false">I / vi
I / vi
IV / V
I
I / - / IV / V&gt;
vi&gt; / IV&gt;
V&gt;&gt; / III&gt;
vi</textarea>
	</div>
	<div style="float: left; margin-left: 5em; width: 350px;">
	<table>
		<thead>
			<tr>
				<th>&nbsp;</th>
				<th>Maj</th>
				<th>Min</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td id="scale1">1</td>
				<td><button onclick="javascript: add('I');">I</button></td>
				<td><button onclick="javascript: add('i');">i</button></td>
			</tr>
			<tr>
				<td id="scale2">2</td>
				<td><button onclick="javascript: add('II');">II</button></td>
				<td><button onclick="javascript: add('ii');">ii</button></td>
			</tr>
			<tr>
				<td id="scale3">3</td>
				<td><button onclick="javascript: add('III');">III</button></td>
				<td><button onclick="javascript: add('iii');">iii</button></td>
			</tr>
			<tr>
				<td id="scale4">4</td>
				<td><button onclick="javascript: add('IV');">IV</button></td>
				<td><button onclick="javascript: add('iv');">iv</button></td>
			</tr>
			<tr>
				<td id="scale5">5</td>
				<td><button onclick="javascript: add('V');">V</button></td>
				<td><button onclick="javascript: add('v');">v</button></td>
			</tr>
			<tr>
				<td id="scale6">6</td>
				<td><button onclick="javascript: add('VI');">VI</button></td>
				<td><button onclick="javascript: add('vi');">vi</button></td>
			</tr>
			<tr>
				<td id="scale7">7</td>
				<td><button onclick="javascript: add('VII');">VII</button></td>
				<td><button onclick="javascript: add('vii');">vii</button></td>
			</tr>
		</tbody>
	</table>
	<p>
		Chords can be prefixed with <code>#</code> or <code>b</code> to sharpen or flatten by a
		semitone.
	</p>
	<p>
		Chords can end with <code>&lt;</code> or <code>&gt;</code> multiple times to move down or up
		the keys using inversions.
	</p>
	<p style="text-align: center;">
		<button class="doit" onclick="javascript: play();">PLAY</button>
		<button class="doit" onclick="javascript: stop();">STOP</button>
	</p>
	<p id="out">&nbsp;</p>
	<p>Detected Modes: <span id="modes">?</span></p>
	</div>
	<script>

function getProg(){
	var p = document.getElementById('prog').value;
	if (p.replace(/^\s+|\s+$/g, '') === '')
		return [];
	p.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
	return p.split('\n');
}

function setProg(p){
	document.getElementById('prog').value = p.join('\n');
}

var volume = 50;

function addVolume(v){
	volume = Math.min(Math.max(volume + v, 10), 100);
	document.getElementById('vol').innerHTML = volume === 100 ? 99 : volume;
}
addVolume(0);

function add(ch){
	var p = getProg();
	p.push(ch);
	setProg(p);
}

function updateScaleDegrees(){
	var keyofe = document.getElementById('keyof');
	var keyof = parseFloat(keyofe.options[keyofe.selectedIndex].value);
	if (keyof < 0)
		keyof += 12;
	var keys = [
		['C' , 'D' , 'E' , 'F' , 'G' , 'A' , 'B' ],
		['Db', 'Eb', 'F' , 'Gb', 'Ab', 'Bb', 'C' ],
		['D' , 'E' , 'F#', 'G' , 'A' , 'B' , 'C#'],
		['Eb', 'F' , 'G' , 'Ab', 'Bb', 'C' , 'D' ],
		['E' , 'F#', 'G#', 'A' , 'B' , 'C#', 'D#'],
		['F' , 'G' , 'A' , 'Bb', 'C' , 'D' , 'E' ],
		['Gb', 'Ab', 'Bb', 'Cb', 'Db', 'Eb', 'F' ],
		['G' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F#'],
		['Ab', 'Bb', 'C' , 'Db', 'Eb', 'F' , 'G' ],
		['A' , 'B' , 'C#', 'D' , 'E' , 'F#', 'G#'],
		['Bb', 'C' , 'D' , 'Eb', 'F' , 'G' , 'A' ],
		['B' , 'C#', 'D#', 'E' , 'F#', 'G#', 'A#']
	];
	for (var i = 1; i <= 7; i++)
		document.getElementById('scale' + i).innerHTML = keys[keyof][i - 1];
}
document.getElementById('keyof').addEventListener('change', updateScaleDegrees);
updateScaleDegrees();

var schedule = (function(){
	var my = {
		list: [],
		next: 0,
		bpm: 120
	};
	function beat(){
		if (my.list.length <= 0)
			return;
		my.next %= my.list.length;
		var cmds = my.list[my.next++];
		for (var i = 0; i < cmds.length; i++){
			(function(c){
				if (typeof c === 'string'){
					document.getElementById('out').innerHTML = c;
					return;
				}
				var vel = c[1] * volume / 100;
				if (vel > 0)
					setTimeout(function(){ noteHit(c[0], vel); }, Math.floor(Math.random() * 50));
				else
					noteHit(c[0], vel);
			})(cmds[i]);
		}
	}
	var acc = 0;
	var last = performance.now();
	function tick(){
		var now = performance.now();
		var dt = now - last;
		last = now;
		acc += dt;
		if (acc >= 60000 / my.bpm){
			acc = 0;
			beat();
		}
	}
	setInterval(tick, 0);
	return my;
})();

function notesToSchedule(notes){
	var list = [];
	for (var i = 0; i < notes.length; i++)
		list.push([]);
	for (var i = 0; i < notes.length; i++){
		var nt = notes[i];
		for (var j = 0; j < nt.length; j++){
			var n = nt[j];
			if (typeof n === 'string')
				list[i].unshift(n);
			else{
				var midi = n[0];
				var vel  = n[1];
				var dur  = n[2];
				list[i].push([midi, vel]); // note on here
				list[(i + dur) % list.length].unshift([midi, 0]); // note off `dur` later
			}
		}
	}
	return list;
}

function chordsToNotes(keyof, chords){
	function hsc(str){ return ('' + str).replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
	var TREB_VEL = function(){ return Math.random() * 0.05 + 0.4; };
	var BASS_VEL  = function(){ return Math.random() * 0.05 + 0.4; };
	var notes = [];
	var lastchord = '';
	for (var i = 0; i < chords.length; i++){
		var ch = chords[i];
		var dur = 0;
		var repeat = false;
		if (ch.chord === ''){
			repeat = true;
			ch = lastch;
		}
		else{
			lastch = ch;
			for (dur = i + 1; dur < chords.length; dur++){
				if (chords[dur].chord !== '')
					break;
			}
			dur -= i;
		}
		// output notes using duration
		var nt = [];
		if (repeat)
			nt.push('<span style="color: #' +
				(i % 2 == 0 ? '888' : '777') + ';">' + hsc(ch.chord) + '</span>');
		else
			nt.push(hsc(ch.chord));
		if (!repeat){
			// bass
			nt.push([36 + ch.bass + keyof, BASS_VEL(), dur]);
			nt.push([43 + ch.bass + keyof, BASS_VEL(), dur]);
			nt.push([48 + ch.bass + keyof, BASS_VEL(), dur]);
		}
		// treble
		for (var j = 0; j < ch.treb.length; j++)
			nt.push([60 + ch.treb[j] + keyof, TREB_VEL(), 1]);
		notes.push(nt);
	}
	return notes;
}

function chordToBassTreble(chord){
	var body = chord;
	var treb = false;
	var bass = false;
	var shift = 0;
	var rotate = 0;
	while (true){
		if (body.charAt(0) === 'b'){
			shift--;
			body = body.substr(1);
		}
		else if (body.charAt(0) === '#'){
			shift++;
			body = body.substr(1);
		}
		else if (body.charAt(body.length - 1) === '<'){
			rotate--;
			body = body.substr(0, body.length - 1);
		}
		else if (body.charAt(body.length - 1) === '>'){
			rotate++;
			body = body.substr(0, body.length - 1);
		}
		else
			break;
	}
	//  _____       _____ _____       _____ _____ _____
	// | -2  |     |  1  |  3  |     |  6  |  8  | 10  |
	// |_____|__ __|_____|_____|_____|_____|_____|_____|__
	//    |  -1 |  0  |  2  |  4  |  5  |  7  |  9  | 11  |
	//    |_____|_____|_____|_____|_____|_____|_____|_____|
	switch (body){
		case 'I'  : bass =  0; treb = [ 0, 4, 7]; break;
		case 'II' : bass =  2; treb = [ 2, 6, 9]; break;
		case 'III': bass =  4; treb = [-1, 4, 8]; break;
		case 'IV' : bass =  5; treb = [ 0, 5, 9]; break;
		case 'V'  : bass = -5; treb = [-1, 2, 7]; break;
		case 'VI' : bass = -3; treb = [ 1, 4, 9]; break;
		case 'VII': bass = -1; treb = [-1, 3, 6]; break;
		case 'i'  : bass =  0; treb = [ 0, 3, 7]; break;
		case 'ii' : bass =  2; treb = [ 2, 5, 9]; break;
		case 'iii': bass =  4; treb = [-1, 4, 7]; break;
		case 'iv' : bass =  5; treb = [ 0, 5, 8]; break;
		case 'v'  : bass = -5; treb = [-2, 2, 7]; break;
		case 'vi' : bass = -3; treb = [ 0, 4, 9]; break;
		case 'vii': bass = -1; treb = [-1, 2, 6]; break;
		case ''   :
		case '-'  :
			if (body !== chord)
				return false;
			chord = '';
			body = '';
			break;
		default:
			return false;
	}
	if (shift != 0){
		bass += shift;
		for (var i = 0; i < treb.length; i++)
			treb[i] += shift;
	}
	while (rotate > 0){
		treb.push(treb.shift() + 12);
		rotate--;
	}
	while (rotate < 0){
		treb.unshift(treb.pop() - 12);
		rotate++;
	}
	var simp = body;
	if (shift != 0){
		while (shift < 0){
			simp = 'b' + simp;
			shift++;
		}
		while (shift > 0){
			simp = '#' + simp;
			shift--;
		}
	}
	return { chord: chord, simplified: simp, bass: bass, treb: treb };
}

function findModes(simps){
	var modes = {
		'Lydian': ['I', 'II', 'iii', '#ivo', 'V', 'vi', 'vii'],
		'Ionian [Major]': ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'viio'],
		'Mixolydian': ['I', 'ii', 'iiio', 'IV', 'v', 'vi', 'bVII'],
		'Dorian': ['i', 'ii', 'bIII', 'IV', 'v', 'vio', 'bVII'],
		'Aeolian [Minor]': ['i', 'iio', 'bIII', 'iv', 'v', 'bVI', 'bVII'],
		'Phrygian': ['i', 'bII', 'bIII', 'iv', 'vo', 'bVI', 'bvii'],
		'Locrian': ['io', 'bII', 'biii', 'iv', 'bV', 'bVI', 'bvii']
	};
	var m = [];
	for (var k in modes){
		var found = true;
		for (var i = 0; i < simps.length && found; i++)
			found = modes[k].indexOf(simps[i]) >= 0;
		if (found)
			m.push(k);
	}
	return m;
}

function play(){
	stop();
	var p = getProg();
	var lastchordtxt = false;
	var keyofe = document.getElementById('keyof');
	var keyof = parseFloat(keyofe.options[keyofe.selectedIndex].value);
	var chords = [];
	var eachchord = {};
	for (var i = 0; i < p.length; i++){
		if (p[i].substr(0, 4) === 'BAD:')
			continue;
		if (p[i].replace(/\s/g, '') === '')
			continue;
		var row = p[i].split(' / ');
		if (row.length == 1)
			row = [row[0], '', '', ''];
		else if (row.length == 2)
			row = [row[0], '', row[1], ''];
		else if (row.length == 3)
			row = [row[0], row[1], row[2], ''];
		else if (row.length > 4){
			p[i] = 'BAD: ' + p[i];
			setProg(p);
			continue;
		}
		var tbs = [];
		for (var j = 0; j < row.length; j++){
			var tb = chordToBassTreble(row[j].replace(/\s/g, ''));
			if (tb === false){
				tbs = [];
				p[i] = 'BAD: ' + p[i];
				setProg(p);
				break;
			}
			tbs.push(tb);
		}
		for (var j = 0; j < tbs.length; j++){
			var s = tbs[j].simplified;
			if (s !== ''){
				if (typeof eachchord[s] !== 'number')
					eachchord[s] = 0;
				eachchord[s]++;
			}
		}
		chords.push.apply(chords, tbs);
	}
	var simps = [];
	for (var k in eachchord)
		simps.push(k);
	var modes = findModes(simps);
	if (modes.length <= 0){
		// search for modal interchange
		// remove least common chord
		var smallest = 99999;
		for (var k in eachchord)
			smallest = Math.min(smallest, eachchord[k]);
		var smallchords = [];
		for (var k in eachchord){
			if (eachchord[k] === smallest)
				smallchords.push(k);
		}
		for (var i = 0; i < smallchords.length; i++){
			var simps2 = simps.concat();
			simps2.splice(simps2.indexOf(smallchords[i]), 1); // remove chord
			var modes2 = findModes(simps2);
			for (var k = 0; k < modes2.length; k++)
				modes2[k] += ' (ignoring <code>' + smallchords[i] + '</code>)';
			modes = modes.concat(modes2);
		}
	}
	if (modes.length <= 0)
		modes = ['None'];
	if (modes.length == 1)
		document.getElementById('modes').innerHTML = modes[0];
	else
		document.getElementById('modes').innerHTML = '<ol><li>' + modes.join('</li><li>') + '</li></ol>';
	schedule.list = notesToSchedule(chordsToNotes(keyof, chords));
	var bpm = parseFloat(document.getElementById('bpm').value);
	if (!isNaN(bpm) && bpm >= 30 && bpm <= 300)
		schedule.bpm = bpm;
}

function stop(){
	schedule.list = [];
	schedule.next = 0;
	setTimeout(function(){
		for (var i = 0; i < 128; i++)
			noteHit(i, 0);
	}, 500);
}
	</script>
</body>
</html>
